// Copyright (c) 2018 The Peacenet & Alkaline Thunder.

#include "UVulnerabilityTerminalCommand.h"
#include "UHackableHandler.h"

bool UVulnerabilityTerminalCommand::GetService(const FComputer & InComputer, int InPort, FServiceInfo& OutService)
{
	for (auto Service : InComputer.ActiveServices)
	{
		if (Service.Port == InPort)
		{
			OutService = Service;
			return true;
		}
	}
	return false;
}

bool UVulnerabilityTerminalCommand::IsVulnerableAgainst(FName InServiceName, UComputerService *& OutVulnerableService)
{
	for (auto Service : this->Vulnerability->VulnerableAgainst)
	{
		if (Service->InternalID == InServiceName)
		{
			OutVulnerableService = Service;
			return true;
		}
	}
	return false;
}

void UVulnerabilityTerminalCommand::RunCommand(UConsoleContext* InConsole, const TMap<FString, UDocoptValue*> InArguments)
{
	check(this->Vulnerability->VulnerableAgainst.Num());

	if (!this->CanHackAtAll(InConsole->SystemContext))
	{
		InConsole->WriteLine("`3error:`1 this vulnerability attacks services for which you have no programs or commands to connect to. Cannot continue.");
		this->Complete();
		return;
	}

	auto Peacenet = InConsole->SystemContext->Peacenet;

	FString Host = InArguments["<host>"]->AsString();
	int Port = -1;
	if (InArguments.Contains("[port]"))
	{
		Port = InArguments["[port]"]->AsNumber();
	}

	USystemContext* Resolved;
	FString ResolvedIP;

	InConsole->WriteLine("Resolving host...");

	if (Peacenet->ResolveHost(Host, ResolvedIP, Resolved))
	{
		if (Port == -1)
		{
			for (auto Vuln : this->Vulnerability->VulnerableAgainst)
			{
				Port = Vuln->HackableType->Port;
				InConsole->WriteLine("Attempting to exploit " + ResolvedIP + ":" + FString::FromInt(Port) + "...");
				FServiceInfo Service;
				if (this->GetService(Resolved->Computer, Port, Service))
				{
					InConsole->WriteLine("Detected service: " + Service.ServiceName.ToString());
					UComputerService* Vuln;
					if (this->IsVulnerableAgainst(Service.ServiceName, Vuln))
					{
						Vuln->HackableType->Handler->Handle(InConsole->SystemContext, Resolved);
						this->Complete();
						return;
					}
				}
				else
				{
					InConsole->WriteLine("Port is not open, connection refused.");
				}

			}
		}
		else
		{
			InConsole->WriteLine("Attempting to exploit " + ResolvedIP + ":" + FString::FromInt(Port) + "...");
			FServiceInfo Service;
			if (this->GetService(Resolved->Computer, Port, Service))
			{
				InConsole->WriteLine("Detected service: " + Service.ServiceName.ToString());
				UComputerService* Vuln;
				if (this->IsVulnerableAgainst(Service.ServiceName, Vuln))
				{
					Vuln->HackableType->Handler->Handle(InConsole->SystemContext, Resolved);
				}
				else
				{
					InConsole->WriteLine("`3`*FATAL:`1`r Can't proceed, this exploit isn't going to work on that service.");
				}
			}
			else
			{
				InConsole->WriteLine("Port is not open, connection refused.");
			}
		}

		this->Complete();
	}
	else
	{
		InConsole->WriteLine("Couldn't resolve hostname. Stop.");
		this->Complete();
	}

}

bool UVulnerabilityTerminalCommand::CanHackAtAll(USystemContext * InCaller)
{
	for (auto Service : this->Vulnerability->VulnerableAgainst)
	{
		if (this->CanHack(InCaller, Service))
			return true;
	}
	return false;
}

bool UVulnerabilityTerminalCommand::CanHack(USystemContext * InCaller, UComputerService * InService)
{
	return InService && InService->CanHack(InCaller);
}
